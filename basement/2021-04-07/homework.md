# homework

## 2021-04-07

### 1、简述 命名空间在 c++ 中的作用

```c++
namespace namespaceA{
    
}
/* 1. 为了一个程序块儿起一个名字，方便指定 ==》 作用域的概念
	可以区别不同对象在不同作
	
	用域范围的调用
	using namespace namespaceA;
	using namespaceA::a;
	namespaceA::a;
*/ 
```



### 2、定义两个命名空间A 和B分别在A和B中定义变量value，在main函数中将这两个空间中的value打印出来

```c++
#include <iostream>

using namespace std;

namespace A{
    int value = 10;
}

namespace B{
    int value = 20;
}
int main(void){
    std::cout << "A::value = " << A::value << std::endl;
    std::cout << "B::value = " << B::value << std::endl;
	return 0;
}
```

### 3、c语言中三目运算符 ？： 可以充当左值吗？C++是否可以？

```c
#include <stdio.h>
/*
	在 c 语言中，三目运算符是不能充当左值的，因为三目运算符返回的是一个数值域中的数值，并不是一个变量
	但是在 c++ 语言中是可以的，在c++中三目运算符返回的是一个变量的引用，比如下面的语句在 c++ 中返回的是 b 的引用，也就是 (a > b ? a : b) = 30; 等价于 int &ref = b; ref = 30; 而 c++ 中的引用本质是一种常量指针，在这里赋值操作的时候，编译器默认为我们做了一个 取地址的操作 int *const *ref = *b; *ref = 30;
*/
int main(void){
	int a = 10;
    int b = 20;
    // (a > b ? a : b) = 30;    
    
	return 0
}
```



### 4、下面的哪条语句是错误的？为什么？

```c++
(1 < 2 ? a : b) = 100; // 三目运算符返回的是 a 的引用，这里 a 是一个变量，那么 a 就可以执行，该语句是正确的。

(1 < 2 ? 10 : 20) = 100; // 这个是错误的，因为参与三目运算符的数据是常量，不具有栈地址，因此也没有返回对于其的引用，所以不能充当左值
```



### 5、const int a; 在 c++ 编译器中是否需要初始化，为什么？

```c++
const int a; // a 是一个常量，在c++中常量为其分配栈地址空间，只为其在数据区的符号表上开辟一栏，存放 常量的键值对。在编译器编译的时候，将 常量 a 替换成后面的 10。概念和宏定义是相似的，只不过宏是在预处理阶段进行替换的，而常量是在编译的时候进行替换的。 因为 c++ 对于常量是不在栈内分配地址空间，而是采用键值对的方式在符号表中开辟一项来存放。那么就不能想普通变量那样声明和定义可以分开。所以 const int a 在c++编译器中是必须要进行初始化。
```

```c++
const int a = 30;
int *p = (int*)&a;
*p = 20;

// 上面的代码在C++编译器中能够修改a的值吗？*p实际上修改的是谁的值？
/*
	上面三条语句；第一条是将 a 定义为常量，在编译的时候对其进行替换(不是无脑进行替换，需要编译器进行词法分析和文法分析以及语法分析等操作)，不为其在栈内分配地址空间。但是在第二条语句的时候，我们使用了一个指针变量来指向该常量，那么这个时候 c++ 编译器会开辟一个临时空间来供指针来进行指向，因此，这里的 指针p 指向的 该临时空间，而该临时空间和 常量a 是没有关系的。因此在第三条语句中，操作 *p 的对该临时空间进行操作，修改的也是该临时空间内存放的值。
*/
```

### 6、简述引用的特点？

```c++
/*
	1. 引用本质是一个常量指针，在一定的情况下，可以取代指针的作用
	2. 在定义引用的时候必须进行初始化，编译器会自动对其进行去地址赋值给该常量指针，进行一个默认转换的操作，同时引用一经初始化就不能进行修改。
	3. 我们可以定义引用的引用，来进行传递
	4. 数据类型 & a; 这里的& 是一个引用，其他的方式都是取地址运算符
*/
```

### 7、如下的写法是否正确？

```c++
int &a;	// 不对，因为这里是a 是一个引用，在c++中定义一个引用必须要对其进行初始化，因为引用的本质是一个常量 指针
```



### 8、下面三个函数中哪个是正确的?

```c++
void swap1(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}// 这个是可以实现 数据 交换的，因为 形参是实参的引用，传递的是实参的别名。对形参的修改就是相当于对实参的修改
void swap2(int a, int b){
    int temp = a;
    a = b;
    b = temp;
}// 不可以，实参和形参是值传递的方式，只是数据的拷贝
void swap3(int *a, int *b){
    int *temp = a;
    *a = *b;
    *b = *temp;
}// 可以实现，因为传递的是指针，是地址，可以实现数据的交换操作
```

### 9、函数返回值如果是引用类型，为什么可以将函数当成左值？什么情况下函数返回值不能充当左值？

```c++
int &get_A(){
    int a = 10;
    return a; // 这里会产生一个警告，因为将函数中的局部变量作为一个引用返回给调用的地方。当函数执行完成之后，系统会自动释放局部变量，因此函数返回值将没有意义，也就是常量指针的指向就会为空，程序出错。
}
int &get_A1(){
    static int a = 10; // 或者 是通过malloc来分配一个地址空间且没有倍 free的时候可以被释放
    return a;	// 但是在这里，数据a 并不是一个局部变量，而是一个全局变量，在程序开始到最后结束，该变量只被初始化一次，数据保存在全局变量区，当程序结束的时候对其进行释放内存。
} // 这个时候函数返回值是一个全局变量的引用，当函数调用完成的时候，该变量不会被释放，因此可以将其设置为左值，此时将设 get_A1() = 20； 代表的含义是指 int &b = a; b = 20;

/*
	综上所述，
	1. 当引用作为函数的返回值的时候，返回的不是局部变量的引用就可以将函数作为一个左值，为期进行赋值
	2. 也就是说，当函数返回的数据的当前函数的局部变量，那么此时就不能充当左值
*/
```



### 10、下面的代码是否是正确的？

```c++
int a = 20; // 定义一个变量 a
const int &re_a = a; // 因为引用是一个常量指针 int *const re_a = &a; 所以左面的语句等价于 const int *const re_a = &a; 	// 我们不能对其进行修改数据域的值，也不能修改该指针的指向
re_a = 30;		// 所以这个操作是不正确的

/*
	对于 const int *const re_a = &a; 该指针成为常量指针常量，不能修改该指针的指向；也不能通过该指针来修改其内部的数据
*/
```

### 11、以下写法是否正确，如果不正确，请修改

```c++
int &a = 20; // 20 是一个常量，编译器不对齐进行分配地址空间，此时&a 指向的是一个常量的别名，没有实际的地址指向，// int *const a = 20; 20不是一个地址，所以不正确

// 修改
int b = 20;
int &a = b;
```

![image-20210408110246435](/home/fengxuewei/c-plus-plus/C++/C-plus-plus-Learning/虚拟内存架构以及函数压栈和出栈操作.png)