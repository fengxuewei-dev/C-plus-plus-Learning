#include <iostream>

using namespace std;
/*
    内联函数的使用：是为了解决宏函数的弊端
*/
void test01();

// 宏函数的定义
// 因为是傻瓜替换，防止其为负数
// 可以解决压栈和出栈的开销，但是解决不了传递参数的弊端
#define MAX(a,b) \
    ((a) > (b) ? (a) : (b))

// 内联函数
// 1、在编译的时候，编译器会将内联函数的函数体自动替换到被调用的地方，编译器可以校验形参的合法性
// 2、省略了函数压栈 和出栈的操作
// 3、当内联函数的声明和定义是被分开的，那么在定义的时候必须加上 inline 关键字，否则还是会按照普通函数进行处理
inline void printAB(int a, int b);

int main(void){
    test01();
    return 0;
}
// 编译器会进行折中处理，当内联函数中的代码量比较庞大，编译器会自动不进行内联函数的操作，执行普通函数的操作，即使你加了 inline 关键字
inline void printAB(int a, int b){
    cout << "a = " << a <<" , b = " << b << endl;
}

void test01(){
    
    int a = 10;
    int b = 20;
    int c = 0;
    
    c = MAX(a, b);
    // 但是当我需要传递 a++， b++ 的时候，宏函数不能达到预期的目的。并没有语法处理能力，没有编译的能力 ，预处理就是无脑把函数展开

    cout << "c = " << c << endl;
#if 0
    // 数据传输的快慢：
    // 寄存器，cpu
    // 缓存：构价很高，一般都是需要一些稀有金属来构造的，cpu缓存很快，所以会直接从缓存取数据 ，缓存再从内存取数据，起到了中间缓存作用
    // 内存:没有io操作，但是有物理内存读和写的操作，一般有16个G
    // 硬盘：写数据的时候要发生磁盘io操作，需要一个用户态和内核的一个切换，所以很慢， 需要往磁盘写，会很慢
    // 网线（网络到服务器数据通信这一块儿走的是网卡，数据交互特别慢）
    for (int i = 0; i < 1000; i++)
    {
        a++;
        b++;
        printAB(a, b);  // 这个会执行函数的压栈和出栈的操作，执行很慢
        /*
            1、 将 printAB 环境压入栈中
            2、 将 a 和 b 的两个形参压入栈中
            3、 将实参的值拷贝到形参中
            4、 执行语句，获得返回值，返回值出栈
            5、 再次压栈 -- 出栈
        */
       /*
        解决方案：
            1. 使用宏函数
            2. 使用内联函数
       */
    }
    
#endif


}