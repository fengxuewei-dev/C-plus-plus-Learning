#include <iostream>

using namespace std;

/*
    函数模版 是如何进行编译的呢？
        .cpp    ---- 预编译器（宏展开） ---- .i(只是把头文件或者 宏进行替换) 
                ---- 编译器 ---- .s(汇编文件) ---- 汇编器（） ---- 目标文件（二进制文件）.o/.obj 
            ----- 链接器（链接.o文件合并，函数调用） ---- 可执行文件(.exe)

                g++ -E xxx.cpp -o xxx.i
                g++ -S xxx.i -o xxx.s
                g++ -c xxx.s -o xxx.o
                g++ xxx.s -o xxx
    
    当我们定义了一个 函数模版（本质上的是一个模版），目前编译器不能确认内部的类型是什么样子的，需要经过一步将其转化为 模版函数（此时是一个函数，可以直接被编译器所调用）。那么从 函数模版 --- 模版函数 的转化关系是怎么进行的呢？
    
    查看汇编文件的时候，我们可以看到 call 出现了新生成的函数

    函数模版通过具体的使用情况来生成不同的函数。编译器会对函数模版进行两次编译，第一次编译是 编译本身的函数模版， 第二次编译是 根据具体的调用情况来进行调用生成相对应的模版函数（这个是具体的函数），
    函数模版到模版函数被成为第一次实例化
*/

#define C_OUT_MAX 1024

template<class T>
void MySwap(T& a, T& b){
    T temp = a;
    a = b;
    b = temp;
}

void test01();

int main(void){
    test01();
    return 0;
}

void test01(){
    int a = 10;
    int b = 20;
    cout << "a = " << a << "  b = " << b << endl;
    MySwap(a, b);       // 函数模版 传递参数必须强对应，不能进行类型转换。这里是隐式转换。编译器会自动来获取数据类型。
    // 编译器会首先来寻找有无对应的 普通函数, 再去找 函数模版 
    cout << "a = " << a << "  b = " << b << endl;
    cout << C_OUT_MAX << endl;
}